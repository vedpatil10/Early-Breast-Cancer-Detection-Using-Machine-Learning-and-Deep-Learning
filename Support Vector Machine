import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, auc, classification_report
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import time
import joblib
import cv2
import traceback
import importlib.util
import os

class EnhancedCancerClassifier:
    def __init__(self):
        self.model = None
        self.pipeline = None
        self.scaler = StandardScaler()
        self.external_feature_extractor = None
        self.feature_extractor_instance = None
        self.segmentation_enabled = True
        
    def load_and_preprocess(self, csv_path):
        """Load and preprocess the feature CSV file"""
        print("Loading data...")

        # Read the CSV file
        self.data = pd.read_csv(csv_path)

        print("\nColumns in the dataset:")
        print(self.data.columns.tolist())

        feature_columns = self.data.select_dtypes(include=[np.number]).columns
        print(f"\nNumber of feature columns found: {len(feature_columns)}")
        print("Feature columns:", feature_columns.tolist())

        non_numeric_columns = self.data.select_dtypes(exclude=[np.number]).columns
        if len(non_numeric_columns) == 0:
            raise ValueError("No label column found in the dataset")

        label_column = non_numeric_columns[0]
        print(f"\nUsing '{label_column}' as the label column")

        self.X = self.data[feature_columns]
        self.y = self.data[label_column]

        print("\nUnique labels found:", self.y.unique().tolist())

        self.y = self.y.apply(lambda x: 1 if 'malignant' in x.lower() else 0)

        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(
            self.X, self.y, test_size=0.2, random_state=42, stratify=self.y
        )

        print("\nData preprocessing completed!")
        print(f"Training set size: {len(self.X_train)}")
        print(f"Testing set size: {len(self.X_test)}")
        print(f"Number of features: {self.X_train.shape[1]}")

        # Store original feature names for later interpretation
        self.feature_names = feature_columns.tolist()

    def train_model(self):
        """Train the SVM model with progress bar"""
        print("Training SVM model...")

        # Create pipeline with only scaling and SVM (no PCA)
        self.pipeline = Pipeline([
            ('scaler', StandardScaler()),
            ('svm', SVC(
                C=10.0,
                kernel='rbf',
                probability=True,
                random_state=42,
                class_weight='balanced'
            ))
        ])

        # Train the pipeline
        with tqdm(total=100, desc="Training Progress") as pbar:
            self.pipeline.fit(self.X_train, self.y_train)
            for i in range(100):
                time.sleep(0.01)
                pbar.update(1)

        # Store model for later use
        self.model = self.pipeline.named_steps['svm']

        print("\nModel training completed!")

        # Get predictions on training set
        train_pred = self.pipeline.predict(self.X_train)
        train_accuracy = accuracy_score(self.y_train, train_pred)
        print(f"Training Accuracy: {train_accuracy:.2%}")

    def evaluate_model(self):
        """Evaluate the model and display metrics"""
        if self.pipeline is None:
            raise ValueError("Model not trained yet! Please train the model first.")

        # Make predictions
        y_pred = self.pipeline.predict(self.X_test)
        y_pred_prob = self.pipeline.predict_proba(self.X_test)[:,1]

        # Accuracy
        accuracy = accuracy_score(self.y_test, y_pred)
        print(f"\nTest Set Accuracy: {accuracy:.2%}")

        # Confusion matrix
        plt.figure(figsize=(8, 6))
        cm = confusion_matrix(self.y_test, y_pred)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
        plt.title('Confusion Matrix')
        plt.ylabel('True Label')
        plt.xlabel('Predicted Label')
        plt.show()

        # ROC curve
        fpr, tpr, _ = roc_curve(self.y_test, y_pred_prob)
        roc_auc = auc(fpr, tpr)

        plt.figure(figsize=(8, 6))
        plt.plot(fpr, tpr, color='darkorange', lw=2,
                label=f'ROC curve (AUC = {roc_auc:.2f})')
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('Receiver Operating Characteristic (ROC) Curve')
        plt.legend(loc="lower right")
        plt.show()

        # Detailed report
        print("\nClassification Report:")
        print(classification_report(self.y_test, y_pred))

        print("\nDetailed Performance Metrics:")
        print(f"True Negatives (Correct Benign): {cm[0,0]}")
        print(f"False Positives (Incorrect Malignant): {cm[0,1]}")
        print(f"False Negatives (Incorrect Benign): {cm[1,0]}")
        print(f"True Positives (Correct Malignant): {cm[1,1]}")

    def import_feature_extractor(self, file_path):
        """Import external feature extraction logic from a Python file"""
        try:
            print(f"\nImporting feature extractor from: {file_path}")

            # Check if file exists
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File not found: {file_path}")

            # Get the file name without extension
            module_name = os.path.splitext(os.path.basename(file_path))[0]

            # Load the module dynamically
            spec = importlib.util.spec_from_file_location(module_name, file_path)
            if spec is None:
                raise ImportError(f"Could not import module from {file_path}")

            feature_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(feature_module)

            # Check if module contains BreastTumorFeatureExtractor class
            if hasattr(feature_module, 'BreastTumorFeatureExtractor'):
                print("Found BreastTumorFeatureExtractor class, creating instance...")
                self.feature_extractor_instance = feature_module.BreastTumorFeatureExtractor()

                # Create a wrapper function to adapt the class's method to our expected calculate_features interface
                def calculate_features_wrapper(image):
                    # Save image to a temporary file
                    temp_image_path = 'temp_image.jpg'
                    cv2.imwrite(temp_image_path, image)

                    # Extract features using the class's method
                    features_dict = self.feature_extractor_instance._extract_features(temp_image_path)

                    # Remove temporary file
                    if os.path.exists(temp_image_path):
                        os.remove(temp_image_path)

                    if features_dict is None:
                        print("Feature extraction failed, using zeros")
                        feature_names = [
                            'mean_radius', 'mean_texture', 'mean_perimeter', 'mean_area', 'mean_smoothness',
                            'mean_compactness', 'mean_concavity', 'mean_concave_points', 'mean_symmetry',
                            'mean_fractal_dimension', 'radius_error', 'texture_error', 'perimeter_error',
                            'area_error', 'smoothness_error', 'compactness_error', 'concavity_error',
                            'concave_points_error', 'symmetry_error', 'fractal_dimension_error',
                            'worst_radius', 'worst_texture', 'worst_perimeter', 'worst_area',
                            'worst_smoothness', 'worst_compactness', 'worst_concavity',
                            'worst_concave_points', 'worst_symmetry', 'worst_fractal_dimension'
                        ]
                        features = np.zeros(30)
                        features_dict = dict(zip(feature_names, features))

                    # Create feature array from dictionary (excluding non-feature keys)
                    feature_keys = [
                        'mean_radius', 'mean_texture', 'mean_perimeter', 'mean_area', 'mean_smoothness',
                        'mean_compactness', 'mean_concavity', 'mean_concave_points', 'mean_symmetry',
                        'mean_fractal_dimension', 'radius_error', 'texture_error', 'perimeter_error',
                        'area_error', 'smoothness_error', 'compactness_error', 'concavity_error',
                        'concave_points_error', 'symmetry_error', 'fractal_dimension_error',
                        'worst_radius', 'worst_texture', 'worst_perimeter', 'worst_area',
                        'worst_smoothness', 'worst_compactness', 'worst_concavity',
                        'worst_concave_points', 'worst_symmetry', 'worst_fractal_dimension'
                    ]

                    features_array = np.array([features_dict[key] for key in feature_keys])
                    return features_array, features_dict

                # Set the wrapper function as our external feature extractor
                self.external_feature_extractor = calculate_features_wrapper
                print("Feature extractor adapter created successfully!")

            # If the module doesn't have the expected class but has calculate_features function directly
            elif hasattr(feature_module, 'calculate_features'):
                print("Found calculate_features function")
                self.external_feature_extractor = feature_module.calculate_features
            else:
                raise AttributeError("The imported module must contain either a 'calculate_features(image)' function or a 'BreastTumorFeatureExtractor' class")

            print("Feature extractor imported successfully!")

            # Get additional information if available
            if hasattr(feature_module, '__doc__') and feature_module.__doc__:
                print(f"\nModule description: {feature_module.__doc__}")

            return True

        except Exception as e:
            print(f"Error importing feature extractor: {str(e)}")
            print(f"Traceback: {traceback.format_exc()}")
            return False

    def segment_mammogram(self, image):
        """
        Segment the mammogram image to detect potential cancer cells
        Returns potential cancerous regions
        """
        # Create a copy of the original image for processing
        processed = image.copy()
        
        # Convert to grayscale if needed
        if len(image.shape) > 2 and image.shape[2] > 1:
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        else:
            gray = image.copy()
            
        # Apply contrast enhancement
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)
            
        # Denoise the image
        denoised = cv2.fastNlMeansDenoising(enhanced, None, 10, 7, 21)
            
        # Apply threshold to segment potential mass regions
        _, binary = cv2.threshold(denoised, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            
        # Apply morphological operations to clean up the mask
        kernel = np.ones((5, 5), np.uint8)
        opened = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=2)
        closed = cv2.morphologyEx(opened, cv2.MORPH_CLOSE, kernel, iterations=2)
            
        # Find contours
        contours, _ = cv2.findContours(closed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
        # Filter contours by size
        min_area = 100  # Minimum area of potential mass
        potential_masses = []
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > min_area:
                potential_masses.append(contour)
                
        # Return the potential masses contours
        return potential_masses
    
    def highlight_cancer_regions(self, image, contours, prediction):
        """
        Highlight potential cancer regions in the original image
        Returns a new image with highlighted regions
        """
        # Create a copy of the image for drawing
        result = image.copy()
        
        # Only highlight regions if the prediction is malignant
        if prediction == "Malignant":
            # Draw all contours on the image with red color
            cv2.drawContours(result, contours, -1, (0, 0, 255), 2)
            
            # Find the largest contour (likely to be the main mass)
            if contours:
                largest_contour = max(contours, key=cv2.contourArea)
                
                # Draw a filled region for the largest contour with transparency
                overlay = result.copy()
                cv2.drawContours(overlay, [largest_contour], -1, (0, 0, 255), -1)
                
                # Add text label near the largest contour
                M = cv2.moments(largest_contour)
                if M["m00"] != 0:
                    cx = int(M["m10"] / M["m00"])
                    cy = int(M["m01"] / M["m00"])
                    cv2.putText(result, "Potential Cancer", (cx - 20, cy - 20),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
                
                # Apply the overlay with transparency
                alpha = 0.3
                cv2.addWeighted(overlay, alpha, result, 1 - alpha, 0, result)
        
        # Add overall prediction text
        cv2.putText(result, f"Prediction: {prediction}", (20, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255) if prediction == "Malignant" else (0, 255, 0), 2)
        
        return result

    def predict_from_image(self, image_path, display_image=True, save_visual_output=False, output_path=None):
        """Predict cancer type directly from image and highlight cancer cells if detected"""
        if self.pipeline is None:
            raise ValueError("Model not trained yet! Please train the model first.")

        print(f"\nReading image from: {image_path}")
        image = cv2.imread(image_path)
        if image is None:
            raise ValueError(f"Could not read image from path: {image_path}")

        print(f"Image loaded successfully. Shape: {image.shape}, Type: {image.dtype}")

        print("\nExtracting features...")
        with tqdm(total=100, desc="Feature Extraction") as pbar:
            try:
                # Use external feature extractor if available, otherwise use internal
                if self.external_feature_extractor:
                    print("Using imported external feature extractor...")
                    features, feature_dict = self.external_feature_extractor(image)
                else:
                    print("Using internal feature calculation logic...")
                    # This is a placeholder; you would need to implement calculate_features method
                    raise NotImplementedError("No feature extractor provided! Please import a feature extractor first.")

                print(f"\nFeatures extracted. Shape: {features.shape}")
                pbar.update(100)
            except Exception as e:
                print(f"\nError in feature extraction: {str(e)}")
                raise

        print("\nProcessing features through pipeline...")
        # Process features through the pipeline
        features_reshaped = features.reshape(1, -1)
        
        prediction = self.pipeline.predict(features_reshaped)[0]
        probability = self.pipeline.predict_proba(features_reshaped)[0]
        confidence = probability[1] if prediction == 1 else probability[0]
        
        cancer_type = "Malignant" if prediction == 1 else "Benign"
        
        prob_benign = 1 - confidence if prediction == 1 else confidence
        prob_malignant = confidence if prediction == 1 else 1 - confidence
        
        print(f"\nPrediction complete: {cancer_type} with {confidence:.2%} confidence")
        
        # Get top features by their absolute values
        top_features = {}
        # Check if values are numeric and convert them if possible
        sorted_features = []
        for k, v in feature_dict.items():
            try:
                # Try to convert to float if it's a string
                if isinstance(v, str):
                    v = float(v)
                sorted_features.append((k, abs(v)))
            except (ValueError, TypeError):
                # Skip features that can't be converted to numbers
                continue
        
        # Sort features by their absolute values
        sorted_features = sorted(sorted_features, key=lambda x: x[1], reverse=True)[:10]
        for feature, importance in sorted_features:
            top_features[feature] = importance
            
        # Segment the image to detect potential cancer cells if enabled
        cancer_regions = None
        result_image = None
        
        if self.segmentation_enabled:
            print("\nSegmenting image to detect potential cancer cells...")
            try:
                potential_regions = self.segment_mammogram(image)
                print(f"Found {len(potential_regions)} potential regions of interest")
                
                # Highlight these regions on the image
                result_image = self.highlight_cancer_regions(image, potential_regions, cancer_type)
                
                # Display the image if requested
                if display_image and result_image is not None:
                    # Use matplotlib to display the image (works in notebooks and scripts)
                    plt.figure(figsize=(10, 8))
                    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
                    plt.title(f"Analysis Result: {cancer_type} with {confidence:.2%} confidence")
                    plt.axis('off')  # Hide axis
                    plt.show()
                
                # Save the output image if requested
                if save_visual_output and output_path:
                    cv2.imwrite(output_path, result_image)
                    print(f"Analysis image saved to: {output_path}")
                    
                # Store regions for returning
                cancer_regions = potential_regions
                
            except Exception as e:
                print(f"Error during image segmentation: {str(e)}")
                print("Continuing with classification result only...")
        
        result = {
            'cancer_type': cancer_type,
            'confidence': confidence,
            'probabilities': {
                'benign': prob_benign,
                'malignant': prob_malignant
            },
            'features': feature_dict,
            'important_features': top_features,
            'cancer_regions': cancer_regions,
            'result_image': result_image  # Return the actual image for further processing
        }
        
        return result

    def save_model(self, path):
        """Save the trained model, scaler, and pipeline"""
        if self.pipeline is None:
            raise ValueError("No trained model to save!")

        model_data = {
            'pipeline': self.pipeline,
            'feature_names': self.feature_names if hasattr(self, 'feature_names') else None
        }
        joblib.dump(model_data, path)
        print(f"Model saved to {path}")

    def load_model(self, path):
        """Load a trained model, scaler, and pipeline"""
        model_data = joblib.load(path)
        self.pipeline = model_data['pipeline']
        self.model = self.pipeline.named_steps['svm']
        self.scaler = self.pipeline.named_steps['scaler']

        if 'feature_names' in model_data and model_data['feature_names'] is not None:
            self.feature_names = model_data['feature_names']

        print("Model loaded successfully!")

def main():
    classifier = EnhancedCancerClassifier()
    feature_extractor_path = None

    while True:
        print("\nEnhanced Cancer Classification System")
        print("1. Load and preprocess data")
        print("2. Train model")
        print("3. Evaluate model")
        print("4. Predict from image (with cancer cell detection)")
        print("5. Save model")
        print("6. Load model")
        print("7. Toggle cancer cell detection")
        print("8. Exit")

        choice = input("\nEnter your choice (1-8): ")

        if choice == '1':
            csv_path = input("Enter the path to your feature CSV file: ")
            try:
                classifier.load_and_preprocess(csv_path)
            except Exception as e:
                print(f"Error loading data: {str(e)}")
                print("\nPlease make sure your CSV file:")
                print("1. Contains numeric feature columns")
                print("2. Has a label column (e.g., 'label' or 'diagnosis')")
                print("3. Is properly formatted and not corrupted")

        elif choice == '2':
            if not hasattr(classifier, 'X_train'):
                print("Please load and preprocess data first (Option 1)")
                continue
            try:
                classifier.train_model()
            except Exception as e:
                print(f"Error training model: {str(e)}")

        elif choice == '3':
            if classifier.pipeline is None:
                print("Please train the model first (Option 2)")
                continue
            try:
                classifier.evaluate_model()
            except Exception as e:
                print(f"Error evaluating model: {str(e)}")

        elif choice == '4':
            if classifier.pipeline is None:
                print("Please train the model first (Option 2)")
                continue
            image_path = input("Enter the path to the mammogram image file: ")

            # Check if feature extractor is imported
            if not classifier.external_feature_extractor:
                # Check if path is already stored
                if feature_extractor_path:
                    try:
                        print(f"Using previously imported feature extractor from: {feature_extractor_path}")
                        classifier.import_feature_extractor(feature_extractor_path)
                    except Exception as e:
                        print(f"Error reusing feature extraction logic: {str(e)}")
                        feature_extractor_path = input("Enter the path to your feature extraction .py file: ")
                        try:
                            classifier.import_feature_extractor(feature_extractor_path)
                        except Exception as e:
                            print(f"Error importing feature extraction logic: {str(e)}")
                            continue
                else:
                    feature_extractor_path = input("Enter the path to your feature extraction .py file: ")
                    try:
                        classifier.import_feature_extractor(feature_extractor_path)
                    except Exception as e:
                        print(f"Error importing feature extraction logic: {str(e)}")
                        continue

            try:
                # First predict and display the image without saving
                result = classifier.predict_from_image(image_path, display_image=True, save_visual_output=False)
                
                print(f"\nPrediction: {result['cancer_type']}")
                print(f"Confidence: {result['confidence']:.2%}")
                print("\nProbabilities:")
                print(f"- Benign: {result['probabilities']['benign']:.2%}")
                print(f"- Malignant: {result['probabilities']['malignant']:.2%}")
                
                if result['cancer_regions'] is not None:
                    print(f"\nDetected {len(result['cancer_regions'])} potential cancer regions")
                
                print("\nKey Features:")
                # Sort features by value in descending order
                sorted_features = sorted(result['features'].items(), key=lambda x: abs(x[1]), reverse=True)
                for feature, value in sorted_features[:10]:  # Show top 10 features
                    print(f"- {feature}: {value:.4f}")
                
                # After displaying, ask if user wants to save the image
                if result['result_image'] is not None:
                    save_choice = input("\nDo you want to save this analyzed image? (y/n): ").lower()
                    if save_choice == 'y' or save_choice == 'yes':
                        output_path = input("Enter path to save the analyzed image: ")
                        if output_path:
                            cv2.imwrite(output_path, result['result_image'])
                            print(f"Analysis image saved to: {output_path}")
                        else:
                            print("No path provided. Image not saved.")
                    else:
                        print("Image not saved.")
                
            except Exception as e:
                print(f"Error processing image: {str(e)}")
                print(traceback.format_exc())

        elif choice == '5':
            if classifier.pipeline is None:
                print("Please train the model first (Option 3 or 4)")
                continue
            path = input("Enter path to save the model: ")
            try:
                classifier.save_model(path)
            except Exception as e:
                print(f"Error saving model: {str(e)}")

        elif choice == '6':
            path = input("Enter path to load the model: ")
            try:
                classifier.load_model(path)
            except Exception as e:
                print(f"Error loading model: {str(e)}")
        
        elif choice == '7':
            classifier.segmentation_enabled = not classifier.segmentation_enabled
            status = "ENABLED" if classifier.segmentation_enabled else "DISABLED"
            print(f"\nCancer cell detection is now {status}")
                
        elif choice == '8':
            print("Done!")
            break
            
        else:
            print("Invalid choice! Please try again.")

if __name__ == "__main__":
    main()
